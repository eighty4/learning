# Akimbo

This is a prototype application stack built on `reactor-netty` and `dagger` for networking/scheduling and dependency injection, respectively. Java's annotation processors generate application wiring at compile time eschewing runtime cycles and startup time -- important metrics for cloud native autoscaling systems.

This project was a big 2020 learning exercise to explore the JDK compiler, Gradle tooling, `GraalVM`, `javapackager` and graph data structures and algorithms.

Beyond that, it's only a convoluted Hello, World application :) This was a *really fun* project to work on. I wish I had more time in 2020 to build this out properly.

## Pre-bake all the startup

The goal of the project was to reduce startup time for apps hosted in an [IoC container](https://en.wikipedia.org/wiki/Inversion_of_control) and provide a modern container for cloud native applications that live within a service mesh supported deployment. Java application frameworks depend heavily on reflection and runtime analysis to instrument cross-cutting concerns like logging, security and observability. Modern cloud native architectures use side-car processes and liberate applications from frameworks designed to solve every kind of problem.

At build time, the [annotations](https://github.com/eighty4/akimbo/tree/main/akimbo-core/src/main/java/eighty4/akimbo/annotation) from the runtime lib `akimbo-core` are used to describe application components and behaviors, such as creating REST services and application startup hooks. Components are also registered for types with [JSR-250 annotations](https://en.wikipedia.org/wiki/Jakarta_Annotations#The_annotations) like `@PostConstruct`, `@Resource` or `@ManagedBean`, or are a type depended on by the constructor of a registered component type. During the build phase, these component types are registered in a graph data structure to optimize dependency resolution. If a [Dagger module](https://dagger.dev/dev-guide/) exists on the application classpath that provides a given component, it will be added to the application's component graph, permitting it to satisfy dependencies of Akimbo and JSR-250 annotated types. Akimbo will generate a Dagger module for all application components that do not have their own Dagger module and @Provides annotated method. All generated sources -- Dagger modules and service bootstrapping -- are created in the `a_k_i_m_b_o` package at the application's root package - where the application's `@AkimboApp` annotated class lives. When the application starts, application components are initialized and started immediately without any runtime resolution!

## Component resolution

Java runs all annotation processors iteratively until a round of processing completes without outputting any new generated code. Akimbo's [ComponentGraph](akimbo-processor/src/main/java/eighty4/akimbo/compile/resolution/ComponentGraph.java) uses Guava's MutableGraph to build a network of type dependencies from application code and the components generated by any other annotation processors. Annotation processors for additional integrations would be able to generate types and initialization boilerplate into the application's generated sources and the next run of [AkimboProcessor](akimbo-processor/src/main/java/eighty4/akimbo/compile/AkimboProcessor.java) would incorporate those components into the application's component graph.

[AkimboCassandraProcessor](akimbo-cassandra-processor/src/main/java/eighty4/akimbo/cassandra/compile/AkimboCassandraProcessor.java) is an example of an annotation processor that creates a [CqlSession](akimbo-cassandra/src/main/java/eighty4/akimbo/cassandra/AkimboCassandraSession.java) with connection details from application properties whenever an [@Entity-annotated](https://docs.datastax.com/en/drivers/java/4.3/com/datastax/oss/driver/api/mapper/annotations/Entity.html) class exists within the project. After `eighty4.akimbo:akimbo-cassandra-processor` generates the Dagger module to provide an [AkimboCassandraSession](akimbo-cassandra/src/main/java/eighty4/akimbo/cassandra/AkimboCassandraSession.java), [AkimboProcessor](akimbo-processor/src/main/java/eighty4/akimbo/compile/AkimboProcessor.java) will run again to process the newly generated types and add them to the [ComponentGraph](akimbo-processor/src/main/java/eighty4/akimbo/compile/resolution/ComponentGraph.java).

`eighty4.akimbo:akimbo-cassandra-processor` has a [META-INF Processor config](akimbo-cassandra-processor/src/main/resources/META-INF/services/javax.annotation.processing.Processor) in its JAR that tells `javac` to use [AkimboCassandraProcessor](akimbo-cassandra-processor/src/main/java/eighty4/akimbo/cassandra/compile/AkimboCassandraProcessor.java) during the processing phase. This makes this convention-over-configuration magic possible by simply adding the `akimbo-cassandra-processor` dependency to an application via Gradle. Compared to previous generations of Java frameworks, this is an enhanced method of auto-magically wiring together bootstrapped integrations - components are only created and called on startup if they're actually used by the application!

## Expression parsing

Components are hardly useful without integrating them with other application components, configuration and state. An expression language is defined with [ANTLR4](https://github.com/antlr/antlr4) to be able to [lex](akimbo-expressions/src/main/antlr/AkimboExpressionsLexer.g4) and [parse](akimbo-expressions/src/main/antlr/AkimboExpressionsParser.g4) expressions that resolve to components and configuration values.

These expressions used with a [@Value](akimbo-core/src/main/java/eighty4/akimbo/annotation/Value.java) annotation on a component's constructor arg can be used to look up and inject a config value from an application's properties files or environment variables.

Combining [@Inject](https://docs.oracle.com/javaee/6/api/javax/inject/Inject.html) with [@Named](https://docs.oracle.com/javaee/6/api/javax/inject/Named.html), components can be dynamically resolved and injected using expressions. Compound expressions allow object construction, method calls, component references and property references like [this example](akimbo-cassandra-processor/src/main/java/eighty4/akimbo/cassandra/compile/AkimboCassandraProcessor.java) from `akimbo-cassandra-processor`:

`"#akimboDaoMapper.method(@Type.fromCql(${akimbo.cassandra.keyspace}))"`

Definitions from the [formal grammar](akimbo-expressions/src/main/antlr/AkimboExpressionsLexer.g4):

* `#` references a component by name - `#myComponent`
* `@` references a type - `@String.valueOf(1)`
* `${my.prop}` resolves a `MY_PROP` environment variable or `my.prop` property
